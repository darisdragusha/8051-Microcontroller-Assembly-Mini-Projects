; READ NUMBER FROM DB, LAST CHAR BEFORE ';' INDICATES ITS BASE,
	ORG	0000H
	LJMP	MAIN

RESULT	EQU	30H
BASE	EQU	20H
LENGTH	EQU	21H
LAST_CHAR	EQU	22H
TYPE	EQU	23H
NUMBER	EQU	50H
MAIN:
	ACALL	GET_BASE_AND_LENGTH
	ACALL	CONVERT
	ACALL	DISPLAY
	LJMP	ENDI


GET_BASE_AND_LENGTH:
	MOV	DPTR, #NUM
	MOV	LENGTH, #00H
NEXT_CHAR:
	MOV	LAST_CHAR, A
	CLR	A
	MOVC	A, @A+DPTR
	INC	DPTR
	INC	LENGTH
	CJNE	A, #';', NEXT_CHAR
	MOV	TYPE, LAST_CHAR
	RET

CONVERT:
	MOV	DPTR, #NUM
	MOV	R0, #NUMBER
	MOV	R1, #RESULT
	MOV	A, TYPE
	CJNE	A, #'B', OCT
	MOV	BASE, #2
	ACALL	CONVERT_FROM_BINARY
	RET
OCT:
	CJNE	A, #'O', DEC
	MOV	BASE, #8
	ACALL	CONVERT_FROM_OCT
	RET
DEC:
	MOV	BASE, #10
	ACALL	CONVERT_FROM_DEC
	RET

CONVERT_FROM_BINARY:
	ACALL	CONVERT_ASCII_TO_NUMBER	;CONVERTS THE ASCII CODE TO AN ACTUAL NUMBER I.E. 0 IN ASCII = 30H, CONVERTS IT TO 00H. ALSO STORES NUMBER IN RAM
	ACALL	CONVERT_NUM_TO_BINARY	;
	RET

CONVERT_FROM_OCT:
	ACALL	CONVERT_ASCII_TO_NUMBER	;
	ACALL	CONVERT_NUM_TO_BINARY	;
	RET
CONVERT_FROM_DEC:
	ACALL	CONVERT_ASCII_TO_NUMBER	;
	ACALL	CONVERT_NUM_TO_BINARY	;
	RET

CONVERT_ASCII_TO_NUMBER:
	MOV	R7, LENGTH	; TEMPORARILY STORE LENGTH
CONVERT_ASCII_TO_NUMBER_LOOP:
	CLR	A
	CLR	C
	MOVC	A, @A+DPTR
	MOV	40H, #30D
	SUBB	A, 40H
	MOV	@R0, A
	INC	R0
	INC	R1
	DJNZ	LENGTH, CONVERT_ASCII_TO_NUMBER_LOOP
	MOV	LENGTH, R7
	MOV	R0, #NUMBER
	RET

CONVERT_NUM_TO_BINARY:
CONVERT_NUM_TO_BINARY_LOOP:
	MOV	R1, RESULT
	MOV	R2, RESULT+1
	MOV	R3, BASE
	ACALL	MUL_16X8
	ACALL	ADD_16AND8
	DJNZ	LENGTH, CONVERT_NUM_TO_BINARY_LOOP

MUL_16X8:
	MOV	A, R3
	MOV	B, R1
	MUL	AB
	MOV	RESULT, A
	MOV	RESULT+1, B
	MOV	A, R3
	MOV	B, R2
	MUL	AB
	MOV	RESULT+2, B
	ADDC	A, RESULT+1
	MOV	RESULT+1, A
	RET

ADD_16AND8:
	MOV	A, RESULT
	ADD	A, @R0		; A +NUMBER
	MOV	RESULT, A
	MOV	A, RESULT+1
	ADDC	A, #0
	MOV	RESULT+1, A
	RET

DISPLAY:
;DISPLAY FUNCTION
	RET

NUM:	DB	'123D;'
ENDI:	END
